// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: arax.proto
#ifndef GRPC_arax_2eproto__INCLUDED
#define GRPC_arax_2eproto__INCLUDED

#include "arax.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace arax {

// ------------------------------ Arax Services -------------------------- 
//
class Arax final {
 public:
  static constexpr char const* service_full_name() {
    return "arax.Arax";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Initialize arax
    // This should be called by all applications prior to using any other Arax
    // function.
    //
    // @return An Arax_pipe_s message instance
    //
    // rpc Arax_init(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
    //
    //
    // Exit and cleanup Arax
    //
    // rpc Arax_exit(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
    //
    //
    // Delete the shared segment
    virtual ::grpc::Status Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_cleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_cleanRaw(context, request, cq));
    }
    //
    // Return number of accelerators of provided type
    virtual ::grpc::Status Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::arax::AccelListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>> AsyncArax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>>(AsyncArax_accel_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>> PrepareAsyncArax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>>(PrepareAsyncArax_accel_listRaw(context, request, cq));
    }
    //
    // Get arax revision
    virtual ::grpc::Status Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::RevisionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>> AsyncArax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>>(AsyncArax_pipe_get_revisionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>> PrepareAsyncArax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>>(PrepareAsyncArax_pipe_get_revisionRaw(context, request, cq));
    }
    //
    // Increase process counter for pipe
    virtual ::grpc::Status Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ProcCounter* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> AsyncArax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(AsyncArax_pipe_add_processRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> PrepareAsyncArax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(PrepareAsyncArax_pipe_add_processRaw(context, request, cq));
    }
    //
    // Decrease process counter for pipe
    virtual ::grpc::Status Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ProcCounter* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> AsyncArax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(AsyncArax_pipe_del_processRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> PrepareAsyncArax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(PrepareAsyncArax_pipe_del_processRaw(context, request, cq));
    }
    //
    // Free memory of accelerator array returned by Arax_accel_list
    virtual ::grpc::Status Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_accel_list_freeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_accel_list_freeRaw(context, request, cq));
    }
    //
    // Return the type of accelerator specified by the client
    virtual ::grpc::Status Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::arax::AccelListRequest* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>> AsyncArax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>>(AsyncArax_accel_typeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>> PrepareAsyncArax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>>(PrepareAsyncArax_accel_typeRaw(context, request, cq));
    }
    //
    // Create an arax buffer object
    //
    virtual ::grpc::Status Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::arax::ResourceID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> AsyncArax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(AsyncArax_bufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> PrepareAsyncArax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(PrepareAsyncArax_bufferRaw(context, request, cq));
    }
    //
    // Register a new process 'func name'
    virtual ::grpc::Status Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::arax::ResourceID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> AsyncArax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(AsyncArax_proc_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> PrepareAsyncArax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(PrepareAsyncArax_proc_registerRaw(context, request, cq));
    }
    //
    // Delete registered arax_proc pointer
    virtual ::grpc::Status Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::arax::ProcCounter* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> AsyncArax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(AsyncArax_proc_putRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>> PrepareAsyncArax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>>(PrepareAsyncArax_proc_putRaw(context, request, cq));
    }
    //
    // Acquire a virtual accelerator of a given type
    virtual ::grpc::Status Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::arax::ResourceID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> AsyncArax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(AsyncArax_accel_acquire_typeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> PrepareAsyncArax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(PrepareAsyncArax_accel_acquire_typeRaw(context, request, cq));
    }
    //
    // Release a previously acquired accelerator
    virtual ::grpc::Status Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_accel_releaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_accel_releaseRaw(context, request, cq));
    }
    //
    // Set data to arax buffer
    virtual ::grpc::Status Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_data_setRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_data_setRaw(context, request, cq));
    }
    //
    // Decrease ref counter of task
    virtual ::grpc::Status Arax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_task_freeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_task_freeRaw(context, request, cq));
    }
    //
    // Issue a new arax_task
    virtual ::grpc::Status Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::arax::ResourceID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> AsyncArax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(AsyncArax_task_issueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> PrepareAsyncArax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(PrepareAsyncArax_task_issueRaw(context, request, cq));
    }
    //
    // Wait for an issued task to complete or fail
    virtual ::grpc::Status Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::arax::Task* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>> AsyncArax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>>(AsyncArax_task_waitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>> PrepareAsyncArax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>>(PrepareAsyncArax_task_waitRaw(context, request, cq));
    }
    //
    // Return an orphan/unassigned virtual accelerator or NULL
    virtual ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ResourceID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> AsyncArax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(AsyncArax_pipe_get_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>> PrepareAsyncArax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>>(PrepareAsyncArax_pipe_get_orphan_vaccelRaw(context, request, cq));
    }
    //
    //
    virtual ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_pipe_add_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_pipe_add_orphan_vaccelRaw(context, request, cq));
    }
    //
    // Function will check if there are orphan vaccels
    // Note: This function might return old values
    virtual ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::Success* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>> AsyncArax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>>(AsyncArax_pipe_have_orphan_vaccelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>> PrepareAsyncArax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>>(PrepareAsyncArax_pipe_have_orphan_vaccelsRaw(context, request, cq));
    }
    //
    // Remove vac from list of orphan vaccels
    virtual ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncArax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncArax_pipe_remove_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncArax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncArax_pipe_remove_orphan_vaccelRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      //
      // Initialize arax
      // This should be called by all applications prior to using any other Arax
      // function.
      //
      // @return An Arax_pipe_s message instance
      //
      // rpc Arax_init(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
      //
      //
      // Exit and cleanup Arax
      //
      // rpc Arax_exit(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
      //
      //
      // Delete the shared segment
      virtual void Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Return number of accelerators of provided type
      virtual void Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Get arax revision
      virtual void Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Increase process counter for pipe
      virtual void Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Decrease process counter for pipe
      virtual void Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Free memory of accelerator array returned by Arax_accel_list
      virtual void Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Return the type of accelerator specified by the client
      virtual void Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Create an arax buffer object
      //
      virtual void Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Register a new process 'func name'
      virtual void Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Delete registered arax_proc pointer
      virtual void Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Acquire a virtual accelerator of a given type
      virtual void Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Release a previously acquired accelerator
      virtual void Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Set data to arax buffer
      virtual void Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Decrease ref counter of task
      virtual void Arax_task_free(::grpc::ClientContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_task_free(::grpc::ClientContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Issue a new arax_task
      virtual void Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Wait for an issued task to complete or fail
      virtual void Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task* request, ::arax::Task* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task* request, ::arax::Task* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Return an orphan/unassigned virtual accelerator or NULL
      virtual void Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      //
      virtual void Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Function will check if there are orphan vaccels
      // Note: This function might return old values
      virtual void Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Remove vac from list of orphan vaccels
      virtual void Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_cleanRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_cleanRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>* AsyncArax_accel_listRaw(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListResponse>* PrepareAsyncArax_accel_listRaw(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>* AsyncArax_pipe_get_revisionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::RevisionResponse>* PrepareAsyncArax_pipe_get_revisionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* AsyncArax_pipe_add_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* PrepareAsyncArax_pipe_add_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* AsyncArax_pipe_del_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* PrepareAsyncArax_pipe_del_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_accel_list_freeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_accel_list_freeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>* AsyncArax_accel_typeRaw(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::AccelListRequest>* PrepareAsyncArax_accel_typeRaw(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* AsyncArax_bufferRaw(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* PrepareAsyncArax_bufferRaw(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* AsyncArax_proc_registerRaw(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* PrepareAsyncArax_proc_registerRaw(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* AsyncArax_proc_putRaw(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ProcCounter>* PrepareAsyncArax_proc_putRaw(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* AsyncArax_accel_acquire_typeRaw(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* PrepareAsyncArax_accel_acquire_typeRaw(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_accel_releaseRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_accel_releaseRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_data_setRaw(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_data_setRaw(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_task_freeRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_task_freeRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* AsyncArax_task_issueRaw(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* PrepareAsyncArax_task_issueRaw(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>* AsyncArax_task_waitRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::Task>* PrepareAsyncArax_task_waitRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* AsyncArax_pipe_get_orphan_vaccelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::ResourceID>* PrepareAsyncArax_pipe_get_orphan_vaccelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_pipe_add_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_pipe_add_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>* AsyncArax_pipe_have_orphan_vaccelsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::arax::Success>* PrepareAsyncArax_pipe_have_orphan_vaccelsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncArax_pipe_remove_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncArax_pipe_remove_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_cleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_cleanRaw(context, request, cq));
    }
    ::grpc::Status Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::arax::AccelListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>> AsyncArax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>>(AsyncArax_accel_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>> PrepareAsyncArax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>>(PrepareAsyncArax_accel_listRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::RevisionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>> AsyncArax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>>(AsyncArax_pipe_get_revisionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>> PrepareAsyncArax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>>(PrepareAsyncArax_pipe_get_revisionRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ProcCounter* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> AsyncArax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(AsyncArax_pipe_add_processRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> PrepareAsyncArax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(PrepareAsyncArax_pipe_add_processRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ProcCounter* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> AsyncArax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(AsyncArax_pipe_del_processRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> PrepareAsyncArax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(PrepareAsyncArax_pipe_del_processRaw(context, request, cq));
    }
    ::grpc::Status Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_accel_list_freeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_accel_list_freeRaw(context, request, cq));
    }
    ::grpc::Status Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::arax::AccelListRequest* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>> AsyncArax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>>(AsyncArax_accel_typeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>> PrepareAsyncArax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>>(PrepareAsyncArax_accel_typeRaw(context, request, cq));
    }
    ::grpc::Status Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::arax::ResourceID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> AsyncArax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(AsyncArax_bufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> PrepareAsyncArax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(PrepareAsyncArax_bufferRaw(context, request, cq));
    }
    ::grpc::Status Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::arax::ResourceID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> AsyncArax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(AsyncArax_proc_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> PrepareAsyncArax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(PrepareAsyncArax_proc_registerRaw(context, request, cq));
    }
    ::grpc::Status Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::arax::ProcCounter* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> AsyncArax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(AsyncArax_proc_putRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>> PrepareAsyncArax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>>(PrepareAsyncArax_proc_putRaw(context, request, cq));
    }
    ::grpc::Status Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::arax::ResourceID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> AsyncArax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(AsyncArax_accel_acquire_typeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> PrepareAsyncArax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(PrepareAsyncArax_accel_acquire_typeRaw(context, request, cq));
    }
    ::grpc::Status Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_accel_releaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_accel_releaseRaw(context, request, cq));
    }
    ::grpc::Status Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_data_setRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_data_set(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_data_setRaw(context, request, cq));
    }
    ::grpc::Status Arax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_task_freeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_task_free(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_task_freeRaw(context, request, cq));
    }
    ::grpc::Status Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::arax::ResourceID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> AsyncArax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(AsyncArax_task_issueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> PrepareAsyncArax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(PrepareAsyncArax_task_issueRaw(context, request, cq));
    }
    ::grpc::Status Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::arax::Task* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Task>> AsyncArax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Task>>(AsyncArax_task_waitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Task>> PrepareAsyncArax_task_wait(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Task>>(PrepareAsyncArax_task_waitRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::ResourceID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> AsyncArax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(AsyncArax_pipe_get_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>> PrepareAsyncArax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>>(PrepareAsyncArax_pipe_get_orphan_vaccelRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_pipe_add_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_pipe_add_orphan_vaccelRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::arax::Success* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Success>> AsyncArax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Success>>(AsyncArax_pipe_have_orphan_vaccelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Success>> PrepareAsyncArax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::arax::Success>>(PrepareAsyncArax_pipe_have_orphan_vaccelsRaw(context, request, cq));
    }
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncArax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncArax_pipe_remove_orphan_vaccelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncArax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncArax_pipe_remove_orphan_vaccelRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_clean(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response, std::function<void(::grpc::Status)>) override;
      void Arax_accel_list(::grpc::ClientContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_get_revision(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_add_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_del_process(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_accel_list_free(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response, std::function<void(::grpc::Status)>) override;
      void Arax_accel_type(::grpc::ClientContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) override;
      void Arax_buffer(::grpc::ClientContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) override;
      void Arax_proc_register(::grpc::ClientContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response, std::function<void(::grpc::Status)>) override;
      void Arax_proc_put(::grpc::ClientContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) override;
      void Arax_accel_acquire_type(::grpc::ClientContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_accel_release(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_data_set(::grpc::ClientContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_task_free(::grpc::ClientContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_task_free(::grpc::ClientContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) override;
      void Arax_task_issue(::grpc::ClientContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task* request, ::arax::Task* response, std::function<void(::grpc::Status)>) override;
      void Arax_task_wait(::grpc::ClientContext* context, const ::arax::Task* request, ::arax::Task* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_get_orphan_vaccel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_add_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_have_orphan_vaccels(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void Arax_pipe_remove_orphan_vaccel(::grpc::ClientContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_cleanRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_cleanRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>* AsyncArax_accel_listRaw(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::AccelListResponse>* PrepareAsyncArax_accel_listRaw(::grpc::ClientContext* context, const ::arax::AccelListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>* AsyncArax_pipe_get_revisionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::RevisionResponse>* PrepareAsyncArax_pipe_get_revisionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* AsyncArax_pipe_add_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* PrepareAsyncArax_pipe_add_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* AsyncArax_pipe_del_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* PrepareAsyncArax_pipe_del_processRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_accel_list_freeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_accel_list_freeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>* AsyncArax_accel_typeRaw(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::AccelListRequest>* PrepareAsyncArax_accel_typeRaw(::grpc::ClientContext* context, const ::arax::AccelDescriptor& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* AsyncArax_bufferRaw(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* PrepareAsyncArax_bufferRaw(::grpc::ClientContext* context, const ::arax::RequestBuffer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* AsyncArax_proc_registerRaw(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* PrepareAsyncArax_proc_registerRaw(::grpc::ClientContext* context, const ::arax::ProcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* AsyncArax_proc_putRaw(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ProcCounter>* PrepareAsyncArax_proc_putRaw(::grpc::ClientContext* context, const ::arax::AraxProc& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* AsyncArax_accel_acquire_typeRaw(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* PrepareAsyncArax_accel_acquire_typeRaw(::grpc::ClientContext* context, const ::arax::AccelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_accel_releaseRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_accel_releaseRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_data_setRaw(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_data_setRaw(::grpc::ClientContext* context, const ::arax::DataSet& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_task_freeRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_task_freeRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* AsyncArax_task_issueRaw(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* PrepareAsyncArax_task_issueRaw(::grpc::ClientContext* context, const ::arax::TaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::Task>* AsyncArax_task_waitRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::Task>* PrepareAsyncArax_task_waitRaw(::grpc::ClientContext* context, const ::arax::Task& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* AsyncArax_pipe_get_orphan_vaccelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::ResourceID>* PrepareAsyncArax_pipe_get_orphan_vaccelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_pipe_add_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_pipe_add_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::Success>* AsyncArax_pipe_have_orphan_vaccelsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::arax::Success>* PrepareAsyncArax_pipe_have_orphan_vaccelsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncArax_pipe_remove_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncArax_pipe_remove_orphan_vaccelRaw(::grpc::ClientContext* context, const ::arax::ResourceID& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_clean_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_accel_list_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_get_revision_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_add_process_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_del_process_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_accel_list_free_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_accel_type_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_buffer_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_proc_register_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_proc_put_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_accel_acquire_type_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_accel_release_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_data_set_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_task_free_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_task_issue_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_task_wait_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_get_orphan_vaccel_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_add_orphan_vaccel_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_have_orphan_vaccels_;
    const ::grpc::internal::RpcMethod rpcmethod_Arax_pipe_remove_orphan_vaccel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Initialize arax
    // This should be called by all applications prior to using any other Arax
    // function.
    //
    // @return An Arax_pipe_s message instance
    //
    // rpc Arax_init(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
    //
    //
    // Exit and cleanup Arax
    //
    // rpc Arax_exit(google.protobuf.Empty) returns (google.protobuf.Empty) {} 
    //
    //
    // Delete the shared segment
    virtual ::grpc::Status Arax_clean(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    //
    // Return number of accelerators of provided type
    virtual ::grpc::Status Arax_accel_list(::grpc::ServerContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response);
    //
    // Get arax revision
    virtual ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response);
    //
    // Increase process counter for pipe
    virtual ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response);
    //
    // Decrease process counter for pipe
    virtual ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response);
    //
    // Free memory of accelerator array returned by Arax_accel_list
    virtual ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    //
    // Return the type of accelerator specified by the client
    virtual ::grpc::Status Arax_accel_type(::grpc::ServerContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response);
    //
    // Create an arax buffer object
    //
    virtual ::grpc::Status Arax_buffer(::grpc::ServerContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response);
    //
    // Register a new process 'func name'
    virtual ::grpc::Status Arax_proc_register(::grpc::ServerContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response);
    //
    // Delete registered arax_proc pointer
    virtual ::grpc::Status Arax_proc_put(::grpc::ServerContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response);
    //
    // Acquire a virtual accelerator of a given type
    virtual ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response);
    //
    // Release a previously acquired accelerator
    virtual ::grpc::Status Arax_accel_release(::grpc::ServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response);
    //
    // Set data to arax buffer
    virtual ::grpc::Status Arax_data_set(::grpc::ServerContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response);
    //
    // Decrease ref counter of task
    virtual ::grpc::Status Arax_task_free(::grpc::ServerContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response);
    //
    // Issue a new arax_task
    virtual ::grpc::Status Arax_task_issue(::grpc::ServerContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response);
    //
    // Wait for an issued task to complete or fail
    virtual ::grpc::Status Arax_task_wait(::grpc::ServerContext* context, const ::arax::Task* request, ::arax::Task* response);
    //
    // Return an orphan/unassigned virtual accelerator or NULL
    virtual ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response);
    //
    //
    virtual ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response);
    //
    // Function will check if there are orphan vaccels
    // Note: This function might return old values
    virtual ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response);
    //
    // Remove vac from list of orphan vaccels
    virtual ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_clean() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_clean(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_list(::grpc::ServerContext* context, ::arax::AccelListRequest* request, ::grpc::ServerAsyncResponseWriter< ::arax::AccelListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_get_revision(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::arax::RevisionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_add_process(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::arax::ProcCounter>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_del_process(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::arax::ProcCounter>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_list_free(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_type(::grpc::ServerContext* context, ::arax::AccelDescriptor* request, ::grpc::ServerAsyncResponseWriter< ::arax::AccelListRequest>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_buffer(::grpc::ServerContext* context, ::arax::RequestBuffer* request, ::grpc::ServerAsyncResponseWriter< ::arax::ResourceID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_proc_register(::grpc::ServerContext* context, ::arax::ProcRequest* request, ::grpc::ServerAsyncResponseWriter< ::arax::ResourceID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_proc_put(::grpc::ServerContext* context, ::arax::AraxProc* request, ::grpc::ServerAsyncResponseWriter< ::arax::ProcCounter>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_acquire_type(::grpc::ServerContext* context, ::arax::AccelRequest* request, ::grpc::ServerAsyncResponseWriter< ::arax::ResourceID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_release(::grpc::ServerContext* context, ::arax::ResourceID* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_data_set(::grpc::ServerContext* context, ::arax::DataSet* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_free(::grpc::ServerContext* context, ::arax::Task* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_issue(::grpc::ServerContext* context, ::arax::TaskRequest* request, ::grpc::ServerAsyncResponseWriter< ::arax::ResourceID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_wait(::grpc::ServerContext* context, ::arax::Task* request, ::grpc::ServerAsyncResponseWriter< ::arax::Task>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_get_orphan_vaccel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::arax::ResourceID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_add_orphan_vaccel(::grpc::ServerContext* context, ::arax::ResourceID* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_have_orphan_vaccels(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::arax::Success>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_remove_orphan_vaccel(::grpc::ServerContext* context, ::arax::ResourceID* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Arax_clean<WithAsyncMethod_Arax_accel_list<WithAsyncMethod_Arax_pipe_get_revision<WithAsyncMethod_Arax_pipe_add_process<WithAsyncMethod_Arax_pipe_del_process<WithAsyncMethod_Arax_accel_list_free<WithAsyncMethod_Arax_accel_type<WithAsyncMethod_Arax_buffer<WithAsyncMethod_Arax_proc_register<WithAsyncMethod_Arax_proc_put<WithAsyncMethod_Arax_accel_acquire_type<WithAsyncMethod_Arax_accel_release<WithAsyncMethod_Arax_data_set<WithAsyncMethod_Arax_task_free<WithAsyncMethod_Arax_task_issue<WithAsyncMethod_Arax_task_wait<WithAsyncMethod_Arax_pipe_get_orphan_vaccel<WithAsyncMethod_Arax_pipe_add_orphan_vaccel<WithAsyncMethod_Arax_pipe_have_orphan_vaccels<WithAsyncMethod_Arax_pipe_remove_orphan_vaccel<Service > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_clean() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Arax_clean(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_clean(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_clean(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::AccelListRequest, ::arax::AccelListResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::AccelListRequest* request, ::arax::AccelListResponse* response) { return this->Arax_accel_list(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_accel_list(
        ::grpc::MessageAllocator< ::arax::AccelListRequest, ::arax::AccelListResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::AccelListRequest, ::arax::AccelListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_list(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::RevisionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::arax::RevisionResponse* response) { return this->Arax_pipe_get_revision(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_get_revision(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::arax::RevisionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::RevisionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_get_revision(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ProcCounter>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response) { return this->Arax_pipe_add_process(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_add_process(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::arax::ProcCounter>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ProcCounter>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_add_process(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ProcCounter>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::arax::ProcCounter* response) { return this->Arax_pipe_del_process(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_del_process(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::arax::ProcCounter>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ProcCounter>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_del_process(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Arax_accel_list_free(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_accel_list_free(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_list_free(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::AccelDescriptor, ::arax::AccelListRequest>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::AccelDescriptor* request, ::arax::AccelListRequest* response) { return this->Arax_accel_type(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_accel_type(
        ::grpc::MessageAllocator< ::arax::AccelDescriptor, ::arax::AccelListRequest>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::AccelDescriptor, ::arax::AccelListRequest>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_type(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::RequestBuffer, ::arax::ResourceID>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::RequestBuffer* request, ::arax::ResourceID* response) { return this->Arax_buffer(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_buffer(
        ::grpc::MessageAllocator< ::arax::RequestBuffer, ::arax::ResourceID>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::RequestBuffer, ::arax::ResourceID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_buffer(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::ProcRequest, ::arax::ResourceID>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::ProcRequest* request, ::arax::ResourceID* response) { return this->Arax_proc_register(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_proc_register(
        ::grpc::MessageAllocator< ::arax::ProcRequest, ::arax::ResourceID>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::ProcRequest, ::arax::ResourceID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_proc_register(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::AraxProc, ::arax::ProcCounter>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::AraxProc* request, ::arax::ProcCounter* response) { return this->Arax_proc_put(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_proc_put(
        ::grpc::MessageAllocator< ::arax::AraxProc, ::arax::ProcCounter>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::AraxProc, ::arax::ProcCounter>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_proc_put(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::AccelRequest, ::arax::ResourceID>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::AccelRequest* request, ::arax::ResourceID* response) { return this->Arax_accel_acquire_type(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_accel_acquire_type(
        ::grpc::MessageAllocator< ::arax::AccelRequest, ::arax::ResourceID>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::AccelRequest, ::arax::ResourceID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_acquire_type(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response) { return this->Arax_accel_release(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_accel_release(
        ::grpc::MessageAllocator< ::arax::ResourceID, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_release(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::DataSet, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::DataSet* request, ::google::protobuf::Empty* response) { return this->Arax_data_set(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_data_set(
        ::grpc::MessageAllocator< ::arax::DataSet, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::DataSet, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_data_set(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::Task, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::Task* request, ::google::protobuf::Empty* response) { return this->Arax_task_free(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_task_free(
        ::grpc::MessageAllocator< ::arax::Task, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::Task, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_free(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::TaskRequest, ::arax::ResourceID>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::TaskRequest* request, ::arax::ResourceID* response) { return this->Arax_task_issue(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_task_issue(
        ::grpc::MessageAllocator< ::arax::TaskRequest, ::arax::ResourceID>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::TaskRequest, ::arax::ResourceID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_issue(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::Task, ::arax::Task>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::Task* request, ::arax::Task* response) { return this->Arax_task_wait(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_task_wait(
        ::grpc::MessageAllocator< ::arax::Task, ::arax::Task>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::Task, ::arax::Task>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_wait(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ResourceID>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::arax::ResourceID* response) { return this->Arax_pipe_get_orphan_vaccel(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_get_orphan_vaccel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::arax::ResourceID>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::ResourceID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_get_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response) { return this->Arax_pipe_add_orphan_vaccel(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_add_orphan_vaccel(
        ::grpc::MessageAllocator< ::arax::ResourceID, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_add_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::Success>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::arax::Success* response) { return this->Arax_pipe_have_orphan_vaccels(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_have_orphan_vaccels(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::arax::Success>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::arax::Success>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_have_orphan_vaccels(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::arax::ResourceID* request, ::google::protobuf::Empty* response) { return this->Arax_pipe_remove_orphan_vaccel(context, request, response); }));}
    void SetMessageAllocatorFor_Arax_pipe_remove_orphan_vaccel(
        ::grpc::MessageAllocator< ::arax::ResourceID, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::arax::ResourceID, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_remove_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Arax_clean<WithCallbackMethod_Arax_accel_list<WithCallbackMethod_Arax_pipe_get_revision<WithCallbackMethod_Arax_pipe_add_process<WithCallbackMethod_Arax_pipe_del_process<WithCallbackMethod_Arax_accel_list_free<WithCallbackMethod_Arax_accel_type<WithCallbackMethod_Arax_buffer<WithCallbackMethod_Arax_proc_register<WithCallbackMethod_Arax_proc_put<WithCallbackMethod_Arax_accel_acquire_type<WithCallbackMethod_Arax_accel_release<WithCallbackMethod_Arax_data_set<WithCallbackMethod_Arax_task_free<WithCallbackMethod_Arax_task_issue<WithCallbackMethod_Arax_task_wait<WithCallbackMethod_Arax_pipe_get_orphan_vaccel<WithCallbackMethod_Arax_pipe_add_orphan_vaccel<WithCallbackMethod_Arax_pipe_have_orphan_vaccels<WithCallbackMethod_Arax_pipe_remove_orphan_vaccel<Service > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_clean() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_clean() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_clean(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_get_revision(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_add_process(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_del_process(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_list_free(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_type(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_buffer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_proc_register(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_proc_put(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_acquire_type(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_accel_release(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_data_set(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_free(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_issue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_task_wait(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_get_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_add_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_have_orphan_vaccels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestArax_pipe_remove_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_clean() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_clean(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_clean(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_accel_list(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_list(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_get_revision(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_get_revision(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_add_process(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_add_process(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_del_process(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_del_process(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_accel_list_free(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_list_free(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_accel_type(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_buffer(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_buffer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_proc_register(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_proc_register(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_proc_put(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_proc_put(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_accel_acquire_type(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_acquire_type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_accel_release(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_accel_release(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_data_set(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_data_set(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_task_free(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_free(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_task_issue(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_issue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_task_wait(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_task_wait(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_get_orphan_vaccel(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_get_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_add_orphan_vaccel(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_add_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_have_orphan_vaccels(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_have_orphan_vaccels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Arax_pipe_remove_orphan_vaccel(context, request, response); }));
    }
    ~WithRawCallbackMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Arax_pipe_remove_orphan_vaccel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_clean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_clean() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_clean(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_clean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_clean(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_clean(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_accel_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_accel_list() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::AccelListRequest, ::arax::AccelListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::AccelListRequest, ::arax::AccelListResponse>* streamer) {
                       return this->StreamedArax_accel_list(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_accel_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_accel_list(::grpc::ServerContext* /*context*/, const ::arax::AccelListRequest* /*request*/, ::arax::AccelListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_accel_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::AccelListRequest,::arax::AccelListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_get_revision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_get_revision() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::arax::RevisionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::arax::RevisionResponse>* streamer) {
                       return this->StreamedArax_pipe_get_revision(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_get_revision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_get_revision(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::RevisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_get_revision(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::arax::RevisionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_add_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_add_process() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::arax::ProcCounter>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::arax::ProcCounter>* streamer) {
                       return this->StreamedArax_pipe_add_process(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_add_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_add_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_add_process(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::arax::ProcCounter>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_del_process : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_del_process() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::arax::ProcCounter>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::arax::ProcCounter>* streamer) {
                       return this->StreamedArax_pipe_del_process(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_del_process() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_del_process(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_del_process(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::arax::ProcCounter>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_accel_list_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_accel_list_free() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_accel_list_free(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_accel_list_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_accel_list_free(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_accel_list_free(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_accel_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_accel_type() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::AccelDescriptor, ::arax::AccelListRequest>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::AccelDescriptor, ::arax::AccelListRequest>* streamer) {
                       return this->StreamedArax_accel_type(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_accel_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_accel_type(::grpc::ServerContext* /*context*/, const ::arax::AccelDescriptor* /*request*/, ::arax::AccelListRequest* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_accel_type(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::AccelDescriptor,::arax::AccelListRequest>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_buffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_buffer() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::RequestBuffer, ::arax::ResourceID>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::RequestBuffer, ::arax::ResourceID>* streamer) {
                       return this->StreamedArax_buffer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_buffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_buffer(::grpc::ServerContext* /*context*/, const ::arax::RequestBuffer* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_buffer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::RequestBuffer,::arax::ResourceID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_proc_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_proc_register() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::ProcRequest, ::arax::ResourceID>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::ProcRequest, ::arax::ResourceID>* streamer) {
                       return this->StreamedArax_proc_register(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_proc_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_proc_register(::grpc::ServerContext* /*context*/, const ::arax::ProcRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_proc_register(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::ProcRequest,::arax::ResourceID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_proc_put : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_proc_put() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::AraxProc, ::arax::ProcCounter>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::AraxProc, ::arax::ProcCounter>* streamer) {
                       return this->StreamedArax_proc_put(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_proc_put() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_proc_put(::grpc::ServerContext* /*context*/, const ::arax::AraxProc* /*request*/, ::arax::ProcCounter* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_proc_put(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::AraxProc,::arax::ProcCounter>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_accel_acquire_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_accel_acquire_type() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::AccelRequest, ::arax::ResourceID>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::AccelRequest, ::arax::ResourceID>* streamer) {
                       return this->StreamedArax_accel_acquire_type(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_accel_acquire_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_accel_acquire_type(::grpc::ServerContext* /*context*/, const ::arax::AccelRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_accel_acquire_type(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::AccelRequest,::arax::ResourceID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_accel_release : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_accel_release() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::ResourceID, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_accel_release(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_accel_release() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_accel_release(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_accel_release(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::ResourceID,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_data_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_data_set() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::DataSet, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::DataSet, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_data_set(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_data_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_data_set(::grpc::ServerContext* /*context*/, const ::arax::DataSet* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_data_set(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::DataSet,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_task_free : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_task_free() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::Task, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::Task, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_task_free(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_task_free() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_task_free(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_task_free(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::Task,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_task_issue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_task_issue() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::TaskRequest, ::arax::ResourceID>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::TaskRequest, ::arax::ResourceID>* streamer) {
                       return this->StreamedArax_task_issue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_task_issue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_task_issue(::grpc::ServerContext* /*context*/, const ::arax::TaskRequest* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_task_issue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::TaskRequest,::arax::ResourceID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_task_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_task_wait() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::Task, ::arax::Task>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::Task, ::arax::Task>* streamer) {
                       return this->StreamedArax_task_wait(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_task_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_task_wait(::grpc::ServerContext* /*context*/, const ::arax::Task* /*request*/, ::arax::Task* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_task_wait(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::Task,::arax::Task>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_get_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_get_orphan_vaccel() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::arax::ResourceID>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::arax::ResourceID>* streamer) {
                       return this->StreamedArax_pipe_get_orphan_vaccel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_get_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_get_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::ResourceID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_get_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::arax::ResourceID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_add_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_add_orphan_vaccel() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::ResourceID, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_pipe_add_orphan_vaccel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_add_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_add_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_add_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::ResourceID,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_have_orphan_vaccels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_have_orphan_vaccels() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::arax::Success>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::arax::Success>* streamer) {
                       return this->StreamedArax_pipe_have_orphan_vaccels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_have_orphan_vaccels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_have_orphan_vaccels(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::arax::Success* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_have_orphan_vaccels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::arax::Success>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Arax_pipe_remove_orphan_vaccel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Arax_pipe_remove_orphan_vaccel() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::arax::ResourceID, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::arax::ResourceID, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedArax_pipe_remove_orphan_vaccel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Arax_pipe_remove_orphan_vaccel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Arax_pipe_remove_orphan_vaccel(::grpc::ServerContext* /*context*/, const ::arax::ResourceID* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedArax_pipe_remove_orphan_vaccel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::arax::ResourceID,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Arax_clean<WithStreamedUnaryMethod_Arax_accel_list<WithStreamedUnaryMethod_Arax_pipe_get_revision<WithStreamedUnaryMethod_Arax_pipe_add_process<WithStreamedUnaryMethod_Arax_pipe_del_process<WithStreamedUnaryMethod_Arax_accel_list_free<WithStreamedUnaryMethod_Arax_accel_type<WithStreamedUnaryMethod_Arax_buffer<WithStreamedUnaryMethod_Arax_proc_register<WithStreamedUnaryMethod_Arax_proc_put<WithStreamedUnaryMethod_Arax_accel_acquire_type<WithStreamedUnaryMethod_Arax_accel_release<WithStreamedUnaryMethod_Arax_data_set<WithStreamedUnaryMethod_Arax_task_free<WithStreamedUnaryMethod_Arax_task_issue<WithStreamedUnaryMethod_Arax_task_wait<WithStreamedUnaryMethod_Arax_pipe_get_orphan_vaccel<WithStreamedUnaryMethod_Arax_pipe_add_orphan_vaccel<WithStreamedUnaryMethod_Arax_pipe_have_orphan_vaccels<WithStreamedUnaryMethod_Arax_pipe_remove_orphan_vaccel<Service > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Arax_clean<WithStreamedUnaryMethod_Arax_accel_list<WithStreamedUnaryMethod_Arax_pipe_get_revision<WithStreamedUnaryMethod_Arax_pipe_add_process<WithStreamedUnaryMethod_Arax_pipe_del_process<WithStreamedUnaryMethod_Arax_accel_list_free<WithStreamedUnaryMethod_Arax_accel_type<WithStreamedUnaryMethod_Arax_buffer<WithStreamedUnaryMethod_Arax_proc_register<WithStreamedUnaryMethod_Arax_proc_put<WithStreamedUnaryMethod_Arax_accel_acquire_type<WithStreamedUnaryMethod_Arax_accel_release<WithStreamedUnaryMethod_Arax_data_set<WithStreamedUnaryMethod_Arax_task_free<WithStreamedUnaryMethod_Arax_task_issue<WithStreamedUnaryMethod_Arax_task_wait<WithStreamedUnaryMethod_Arax_pipe_get_orphan_vaccel<WithStreamedUnaryMethod_Arax_pipe_add_orphan_vaccel<WithStreamedUnaryMethod_Arax_pipe_have_orphan_vaccels<WithStreamedUnaryMethod_Arax_pipe_remove_orphan_vaccel<Service > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace arax


#endif  // GRPC_arax_2eproto__INCLUDED
