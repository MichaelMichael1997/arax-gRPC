// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arax.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_arax_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_arax_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_arax_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_arax_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_arax_2eproto;
namespace arax {
class AccelDescriptor;
struct AccelDescriptorDefaultTypeInternal;
extern AccelDescriptorDefaultTypeInternal _AccelDescriptor_default_instance_;
class AccelListRequest;
struct AccelListRequestDefaultTypeInternal;
extern AccelListRequestDefaultTypeInternal _AccelListRequest_default_instance_;
class AccelListResponse;
struct AccelListResponseDefaultTypeInternal;
extern AccelListResponseDefaultTypeInternal _AccelListResponse_default_instance_;
class AccelRequest;
struct AccelRequestDefaultTypeInternal;
extern AccelRequestDefaultTypeInternal _AccelRequest_default_instance_;
class AraxProc;
struct AraxProcDefaultTypeInternal;
extern AraxProcDefaultTypeInternal _AraxProc_default_instance_;
class DataSet;
struct DataSetDefaultTypeInternal;
extern DataSetDefaultTypeInternal _DataSet_default_instance_;
class ProcCounter;
struct ProcCounterDefaultTypeInternal;
extern ProcCounterDefaultTypeInternal _ProcCounter_default_instance_;
class ProcRequest;
struct ProcRequestDefaultTypeInternal;
extern ProcRequestDefaultTypeInternal _ProcRequest_default_instance_;
class RequestBuffer;
struct RequestBufferDefaultTypeInternal;
extern RequestBufferDefaultTypeInternal _RequestBuffer_default_instance_;
class ResourceID;
struct ResourceIDDefaultTypeInternal;
extern ResourceIDDefaultTypeInternal _ResourceID_default_instance_;
class RevisionResponse;
struct RevisionResponseDefaultTypeInternal;
extern RevisionResponseDefaultTypeInternal _RevisionResponse_default_instance_;
class Success;
struct SuccessDefaultTypeInternal;
extern SuccessDefaultTypeInternal _Success_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
}  // namespace arax
PROTOBUF_NAMESPACE_OPEN
template<> ::arax::AccelDescriptor* Arena::CreateMaybeMessage<::arax::AccelDescriptor>(Arena*);
template<> ::arax::AccelListRequest* Arena::CreateMaybeMessage<::arax::AccelListRequest>(Arena*);
template<> ::arax::AccelListResponse* Arena::CreateMaybeMessage<::arax::AccelListResponse>(Arena*);
template<> ::arax::AccelRequest* Arena::CreateMaybeMessage<::arax::AccelRequest>(Arena*);
template<> ::arax::AraxProc* Arena::CreateMaybeMessage<::arax::AraxProc>(Arena*);
template<> ::arax::DataSet* Arena::CreateMaybeMessage<::arax::DataSet>(Arena*);
template<> ::arax::ProcCounter* Arena::CreateMaybeMessage<::arax::ProcCounter>(Arena*);
template<> ::arax::ProcRequest* Arena::CreateMaybeMessage<::arax::ProcRequest>(Arena*);
template<> ::arax::RequestBuffer* Arena::CreateMaybeMessage<::arax::RequestBuffer>(Arena*);
template<> ::arax::ResourceID* Arena::CreateMaybeMessage<::arax::ResourceID>(Arena*);
template<> ::arax::RevisionResponse* Arena::CreateMaybeMessage<::arax::RevisionResponse>(Arena*);
template<> ::arax::Success* Arena::CreateMaybeMessage<::arax::Success>(Arena*);
template<> ::arax::Task* Arena::CreateMaybeMessage<::arax::Task>(Arena*);
template<> ::arax::TaskRequest* Arena::CreateMaybeMessage<::arax::TaskRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace arax {

// ===================================================================

class Success final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.Success) */ {
 public:
  inline Success() : Success(nullptr) {}
  ~Success() override;
  explicit PROTOBUF_CONSTEXPR Success(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Success(const Success& from);
  Success(Success&& from) noexcept
    : Success() {
    *this = ::std::move(from);
  }

  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }
  inline Success& operator=(Success&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Success& default_instance() {
    return *internal_default_instance();
  }
  static inline const Success* internal_default_instance() {
    return reinterpret_cast<const Success*>(
               &_Success_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Success& a, Success& b) {
    a.Swap(&b);
  }
  inline void Swap(Success* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Success* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Success* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Success>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Success& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Success& from) {
    Success::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Success* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.Success";
  }
  protected:
  explicit Success(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:arax.Success)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class ResourceID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.ResourceID) */ {
 public:
  inline ResourceID() : ResourceID(nullptr) {}
  ~ResourceID() override;
  explicit PROTOBUF_CONSTEXPR ResourceID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceID(const ResourceID& from);
  ResourceID(ResourceID&& from) noexcept
    : ResourceID() {
    *this = ::std::move(from);
  }

  inline ResourceID& operator=(const ResourceID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceID& operator=(ResourceID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceID* internal_default_instance() {
    return reinterpret_cast<const ResourceID*>(
               &_ResourceID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResourceID& a, ResourceID& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceID& from) {
    ResourceID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.ResourceID";
  }
  protected:
  explicit ResourceID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.ResourceID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class TaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() override;
  explicit PROTOBUF_CONSTEXPR TaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskRequest(const TaskRequest& from);
  TaskRequest(TaskRequest&& from) noexcept
    : TaskRequest() {
    *this = ::std::move(from);
  }

  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
               &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskRequest& a, TaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskRequest& from) {
    TaskRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.TaskRequest";
  }
  protected:
  explicit TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelFieldNumber = 1,
    kProcFieldNumber = 2,
    kInBufferFieldNumber = 4,
    kInCountFieldNumber = 3,
    kOutCountFieldNumber = 5,
    kOutBufferFieldNumber = 6,
  };
  // uint64 accel = 1;
  void clear_accel();
  uint64_t accel() const;
  void set_accel(uint64_t value);
  private:
  uint64_t _internal_accel() const;
  void _internal_set_accel(uint64_t value);
  public:

  // uint64 proc = 2;
  void clear_proc();
  uint64_t proc() const;
  void set_proc(uint64_t value);
  private:
  uint64_t _internal_proc() const;
  void _internal_set_proc(uint64_t value);
  public:

  // uint64 in_buffer = 4;
  void clear_in_buffer();
  uint64_t in_buffer() const;
  void set_in_buffer(uint64_t value);
  private:
  uint64_t _internal_in_buffer() const;
  void _internal_set_in_buffer(uint64_t value);
  public:

  // uint32 in_count = 3;
  void clear_in_count();
  uint32_t in_count() const;
  void set_in_count(uint32_t value);
  private:
  uint32_t _internal_in_count() const;
  void _internal_set_in_count(uint32_t value);
  public:

  // uint32 out_count = 5;
  void clear_out_count();
  uint32_t out_count() const;
  void set_out_count(uint32_t value);
  private:
  uint32_t _internal_out_count() const;
  void _internal_set_out_count(uint32_t value);
  public:

  // uint64 out_buffer = 6;
  void clear_out_buffer();
  uint64_t out_buffer() const;
  void set_out_buffer(uint64_t value);
  private:
  uint64_t _internal_out_buffer() const;
  void _internal_set_out_buffer(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.TaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accel_;
    uint64_t proc_;
    uint64_t in_buffer_;
    uint32_t in_count_;
    uint32_t out_count_;
    uint64_t out_buffer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kTaskStateFieldNumber = 2,
  };
  // uint64 task_id = 1;
  void clear_task_id();
  uint64_t task_id() const;
  void set_task_id(uint64_t value);
  private:
  uint64_t _internal_task_id() const;
  void _internal_set_task_id(uint64_t value);
  public:

  // uint32 task_state = 2;
  void clear_task_state();
  uint32_t task_state() const;
  void set_task_state(uint32_t value);
  private:
  uint32_t _internal_task_state() const;
  void _internal_set_task_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t task_id_;
    uint32_t task_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class DataSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.DataSet) */ {
 public:
  inline DataSet() : DataSet(nullptr) {}
  ~DataSet() override;
  explicit PROTOBUF_CONSTEXPR DataSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataSet(const DataSet& from);
  DataSet(DataSet&& from) noexcept
    : DataSet() {
    *this = ::std::move(from);
  }

  inline DataSet& operator=(const DataSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSet& operator=(DataSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataSet* internal_default_instance() {
    return reinterpret_cast<const DataSet*>(
               &_DataSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataSet& a, DataSet& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataSet& from) {
    DataSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.DataSet";
  }
  protected:
  explicit DataSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrValFieldNumber = 3,
    kBufferFieldNumber = 1,
    kAccelFieldNumber = 2,
  };
  // string str_val = 3;
  void clear_str_val();
  const std::string& str_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_val();
  PROTOBUF_NODISCARD std::string* release_str_val();
  void set_allocated_str_val(std::string* str_val);
  private:
  const std::string& _internal_str_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_val(const std::string& value);
  std::string* _internal_mutable_str_val();
  public:

  // uint64 buffer = 1;
  void clear_buffer();
  uint64_t buffer() const;
  void set_buffer(uint64_t value);
  private:
  uint64_t _internal_buffer() const;
  void _internal_set_buffer(uint64_t value);
  public:

  // uint64 accel = 2;
  void clear_accel();
  uint64_t accel() const;
  void set_accel(uint64_t value);
  private:
  uint64_t _internal_accel() const;
  void _internal_set_accel(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.DataSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_val_;
    uint64_t buffer_;
    uint64_t accel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class AccelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.AccelRequest) */ {
 public:
  inline AccelRequest() : AccelRequest(nullptr) {}
  ~AccelRequest() override;
  explicit PROTOBUF_CONSTEXPR AccelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelRequest(const AccelRequest& from);
  AccelRequest(AccelRequest&& from) noexcept
    : AccelRequest() {
    *this = ::std::move(from);
  }

  inline AccelRequest& operator=(const AccelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelRequest& operator=(AccelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelRequest* internal_default_instance() {
    return reinterpret_cast<const AccelRequest*>(
               &_AccelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AccelRequest& a, AccelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelRequest& from) {
    AccelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.AccelRequest";
  }
  protected:
  explicit AccelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.AccelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class AraxProc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.AraxProc) */ {
 public:
  inline AraxProc() : AraxProc(nullptr) {}
  ~AraxProc() override;
  explicit PROTOBUF_CONSTEXPR AraxProc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AraxProc(const AraxProc& from);
  AraxProc(AraxProc&& from) noexcept
    : AraxProc() {
    *this = ::std::move(from);
  }

  inline AraxProc& operator=(const AraxProc& from) {
    CopyFrom(from);
    return *this;
  }
  inline AraxProc& operator=(AraxProc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AraxProc& default_instance() {
    return *internal_default_instance();
  }
  static inline const AraxProc* internal_default_instance() {
    return reinterpret_cast<const AraxProc*>(
               &_AraxProc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AraxProc& a, AraxProc& b) {
    a.Swap(&b);
  }
  inline void Swap(AraxProc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AraxProc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AraxProc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AraxProc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AraxProc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AraxProc& from) {
    AraxProc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AraxProc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.AraxProc";
  }
  protected:
  explicit AraxProc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.AraxProc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class ProcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.ProcRequest) */ {
 public:
  inline ProcRequest() : ProcRequest(nullptr) {}
  ~ProcRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcRequest(const ProcRequest& from);
  ProcRequest(ProcRequest&& from) noexcept
    : ProcRequest() {
    *this = ::std::move(from);
  }

  inline ProcRequest& operator=(const ProcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcRequest& operator=(ProcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcRequest* internal_default_instance() {
    return reinterpret_cast<const ProcRequest*>(
               &_ProcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProcRequest& a, ProcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcRequest& from) {
    ProcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.ProcRequest";
  }
  protected:
  explicit ProcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncNameFieldNumber = 2,
  };
  // string func_name = 2;
  void clear_func_name();
  const std::string& func_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_func_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_func_name();
  PROTOBUF_NODISCARD std::string* release_func_name();
  void set_allocated_func_name(std::string* func_name);
  private:
  const std::string& _internal_func_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_func_name(const std::string& value);
  std::string* _internal_mutable_func_name();
  public:

  // @@protoc_insertion_point(class_scope:arax.ProcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr func_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class RequestBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.RequestBuffer) */ {
 public:
  inline RequestBuffer() : RequestBuffer(nullptr) {}
  ~RequestBuffer() override;
  explicit PROTOBUF_CONSTEXPR RequestBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBuffer(const RequestBuffer& from);
  RequestBuffer(RequestBuffer&& from) noexcept
    : RequestBuffer() {
    *this = ::std::move(from);
  }

  inline RequestBuffer& operator=(const RequestBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBuffer& operator=(RequestBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBuffer* internal_default_instance() {
    return reinterpret_cast<const RequestBuffer*>(
               &_RequestBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestBuffer& a, RequestBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBuffer& from) {
    RequestBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.RequestBuffer";
  }
  protected:
  explicit RequestBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kBufferSizeFieldNumber = 2,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 buffer_size = 2;
  void clear_buffer_size();
  uint64_t buffer_size() const;
  void set_buffer_size(uint64_t value);
  private:
  uint64_t _internal_buffer_size() const;
  void _internal_set_buffer_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.RequestBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    uint64_t buffer_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class ProcCounter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.ProcCounter) */ {
 public:
  inline ProcCounter() : ProcCounter(nullptr) {}
  ~ProcCounter() override;
  explicit PROTOBUF_CONSTEXPR ProcCounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcCounter(const ProcCounter& from);
  ProcCounter(ProcCounter&& from) noexcept
    : ProcCounter() {
    *this = ::std::move(from);
  }

  inline ProcCounter& operator=(const ProcCounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcCounter& operator=(ProcCounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcCounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcCounter* internal_default_instance() {
    return reinterpret_cast<const ProcCounter*>(
               &_ProcCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProcCounter& a, ProcCounter& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcCounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcCounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcCounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcCounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcCounter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcCounter& from) {
    ProcCounter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcCounter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.ProcCounter";
  }
  protected:
  explicit ProcCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcCounterFieldNumber = 1,
  };
  // uint32 proc_counter = 1;
  void clear_proc_counter();
  uint32_t proc_counter() const;
  void set_proc_counter(uint32_t value);
  private:
  uint32_t _internal_proc_counter() const;
  void _internal_set_proc_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.ProcCounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t proc_counter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class AccelDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.AccelDescriptor) */ {
 public:
  inline AccelDescriptor() : AccelDescriptor(nullptr) {}
  ~AccelDescriptor() override;
  explicit PROTOBUF_CONSTEXPR AccelDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelDescriptor(const AccelDescriptor& from);
  AccelDescriptor(AccelDescriptor&& from) noexcept
    : AccelDescriptor() {
    *this = ::std::move(from);
  }

  inline AccelDescriptor& operator=(const AccelDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelDescriptor& operator=(AccelDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelDescriptor* internal_default_instance() {
    return reinterpret_cast<const AccelDescriptor*>(
               &_AccelDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AccelDescriptor& a, AccelDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelDescriptor& from) {
    AccelDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.AccelDescriptor";
  }
  protected:
  explicit AccelDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.AccelDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class RevisionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.RevisionResponse) */ {
 public:
  inline RevisionResponse() : RevisionResponse(nullptr) {}
  ~RevisionResponse() override;
  explicit PROTOBUF_CONSTEXPR RevisionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevisionResponse(const RevisionResponse& from);
  RevisionResponse(RevisionResponse&& from) noexcept
    : RevisionResponse() {
    *this = ::std::move(from);
  }

  inline RevisionResponse& operator=(const RevisionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevisionResponse& operator=(RevisionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevisionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevisionResponse* internal_default_instance() {
    return reinterpret_cast<const RevisionResponse*>(
               &_RevisionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RevisionResponse& a, RevisionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RevisionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevisionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevisionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevisionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevisionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevisionResponse& from) {
    RevisionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevisionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.RevisionResponse";
  }
  protected:
  explicit RevisionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 1,
  };
  // string revision = 1;
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // @@protoc_insertion_point(class_scope:arax.RevisionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class AccelListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.AccelListRequest) */ {
 public:
  inline AccelListRequest() : AccelListRequest(nullptr) {}
  ~AccelListRequest() override;
  explicit PROTOBUF_CONSTEXPR AccelListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelListRequest(const AccelListRequest& from);
  AccelListRequest(AccelListRequest&& from) noexcept
    : AccelListRequest() {
    *this = ::std::move(from);
  }

  inline AccelListRequest& operator=(const AccelListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelListRequest& operator=(AccelListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelListRequest* internal_default_instance() {
    return reinterpret_cast<const AccelListRequest*>(
               &_AccelListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AccelListRequest& a, AccelListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelListRequest& from) {
    AccelListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.AccelListRequest";
  }
  protected:
  explicit AccelListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPhysicalFieldNumber = 2,
  };
  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // bool physical = 2;
  void clear_physical();
  bool physical() const;
  void set_physical(bool value);
  private:
  bool _internal_physical() const;
  void _internal_set_physical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:arax.AccelListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t type_;
    bool physical_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// -------------------------------------------------------------------

class AccelListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:arax.AccelListResponse) */ {
 public:
  inline AccelListResponse() : AccelListResponse(nullptr) {}
  ~AccelListResponse() override;
  explicit PROTOBUF_CONSTEXPR AccelListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelListResponse(const AccelListResponse& from);
  AccelListResponse(AccelListResponse&& from) noexcept
    : AccelListResponse() {
    *this = ::std::move(from);
  }

  inline AccelListResponse& operator=(const AccelListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelListResponse& operator=(AccelListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelListResponse* internal_default_instance() {
    return reinterpret_cast<const AccelListResponse*>(
               &_AccelListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AccelListResponse& a, AccelListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelListResponse& from) {
    AccelListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "arax.AccelListResponse";
  }
  protected:
  explicit AccelListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptorsFieldNumber = 2,
    kAccelNumFieldNumber = 1,
  };
  // repeated .arax.AccelDescriptor descriptors = 2;
  int descriptors_size() const;
  private:
  int _internal_descriptors_size() const;
  public:
  void clear_descriptors();
  ::arax::AccelDescriptor* mutable_descriptors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arax::AccelDescriptor >*
      mutable_descriptors();
  private:
  const ::arax::AccelDescriptor& _internal_descriptors(int index) const;
  ::arax::AccelDescriptor* _internal_add_descriptors();
  public:
  const ::arax::AccelDescriptor& descriptors(int index) const;
  ::arax::AccelDescriptor* add_descriptors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arax::AccelDescriptor >&
      descriptors() const;

  // uint64 accel_num = 1;
  void clear_accel_num();
  uint64_t accel_num() const;
  void set_accel_num(uint64_t value);
  private:
  uint64_t _internal_accel_num() const;
  void _internal_set_accel_num(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:arax.AccelListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arax::AccelDescriptor > descriptors_;
    uint64_t accel_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_arax_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Success

// bool success = 1;
inline void Success::clear_success() {
  _impl_.success_ = false;
}
inline bool Success::_internal_success() const {
  return _impl_.success_;
}
inline bool Success::success() const {
  // @@protoc_insertion_point(field_get:arax.Success.success)
  return _internal_success();
}
inline void Success::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Success::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:arax.Success.success)
}

// -------------------------------------------------------------------

// ResourceID

// uint64 id = 1;
inline void ResourceID::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t ResourceID::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t ResourceID::id() const {
  // @@protoc_insertion_point(field_get:arax.ResourceID.id)
  return _internal_id();
}
inline void ResourceID::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void ResourceID::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:arax.ResourceID.id)
}

// -------------------------------------------------------------------

// TaskRequest

// uint64 accel = 1;
inline void TaskRequest::clear_accel() {
  _impl_.accel_ = uint64_t{0u};
}
inline uint64_t TaskRequest::_internal_accel() const {
  return _impl_.accel_;
}
inline uint64_t TaskRequest::accel() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.accel)
  return _internal_accel();
}
inline void TaskRequest::_internal_set_accel(uint64_t value) {
  
  _impl_.accel_ = value;
}
inline void TaskRequest::set_accel(uint64_t value) {
  _internal_set_accel(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.accel)
}

// uint64 proc = 2;
inline void TaskRequest::clear_proc() {
  _impl_.proc_ = uint64_t{0u};
}
inline uint64_t TaskRequest::_internal_proc() const {
  return _impl_.proc_;
}
inline uint64_t TaskRequest::proc() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.proc)
  return _internal_proc();
}
inline void TaskRequest::_internal_set_proc(uint64_t value) {
  
  _impl_.proc_ = value;
}
inline void TaskRequest::set_proc(uint64_t value) {
  _internal_set_proc(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.proc)
}

// uint32 in_count = 3;
inline void TaskRequest::clear_in_count() {
  _impl_.in_count_ = 0u;
}
inline uint32_t TaskRequest::_internal_in_count() const {
  return _impl_.in_count_;
}
inline uint32_t TaskRequest::in_count() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.in_count)
  return _internal_in_count();
}
inline void TaskRequest::_internal_set_in_count(uint32_t value) {
  
  _impl_.in_count_ = value;
}
inline void TaskRequest::set_in_count(uint32_t value) {
  _internal_set_in_count(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.in_count)
}

// uint64 in_buffer = 4;
inline void TaskRequest::clear_in_buffer() {
  _impl_.in_buffer_ = uint64_t{0u};
}
inline uint64_t TaskRequest::_internal_in_buffer() const {
  return _impl_.in_buffer_;
}
inline uint64_t TaskRequest::in_buffer() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.in_buffer)
  return _internal_in_buffer();
}
inline void TaskRequest::_internal_set_in_buffer(uint64_t value) {
  
  _impl_.in_buffer_ = value;
}
inline void TaskRequest::set_in_buffer(uint64_t value) {
  _internal_set_in_buffer(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.in_buffer)
}

// uint32 out_count = 5;
inline void TaskRequest::clear_out_count() {
  _impl_.out_count_ = 0u;
}
inline uint32_t TaskRequest::_internal_out_count() const {
  return _impl_.out_count_;
}
inline uint32_t TaskRequest::out_count() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.out_count)
  return _internal_out_count();
}
inline void TaskRequest::_internal_set_out_count(uint32_t value) {
  
  _impl_.out_count_ = value;
}
inline void TaskRequest::set_out_count(uint32_t value) {
  _internal_set_out_count(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.out_count)
}

// uint64 out_buffer = 6;
inline void TaskRequest::clear_out_buffer() {
  _impl_.out_buffer_ = uint64_t{0u};
}
inline uint64_t TaskRequest::_internal_out_buffer() const {
  return _impl_.out_buffer_;
}
inline uint64_t TaskRequest::out_buffer() const {
  // @@protoc_insertion_point(field_get:arax.TaskRequest.out_buffer)
  return _internal_out_buffer();
}
inline void TaskRequest::_internal_set_out_buffer(uint64_t value) {
  
  _impl_.out_buffer_ = value;
}
inline void TaskRequest::set_out_buffer(uint64_t value) {
  _internal_set_out_buffer(value);
  // @@protoc_insertion_point(field_set:arax.TaskRequest.out_buffer)
}

// -------------------------------------------------------------------

// Task

// uint64 task_id = 1;
inline void Task::clear_task_id() {
  _impl_.task_id_ = uint64_t{0u};
}
inline uint64_t Task::_internal_task_id() const {
  return _impl_.task_id_;
}
inline uint64_t Task::task_id() const {
  // @@protoc_insertion_point(field_get:arax.Task.task_id)
  return _internal_task_id();
}
inline void Task::_internal_set_task_id(uint64_t value) {
  
  _impl_.task_id_ = value;
}
inline void Task::set_task_id(uint64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:arax.Task.task_id)
}

// uint32 task_state = 2;
inline void Task::clear_task_state() {
  _impl_.task_state_ = 0u;
}
inline uint32_t Task::_internal_task_state() const {
  return _impl_.task_state_;
}
inline uint32_t Task::task_state() const {
  // @@protoc_insertion_point(field_get:arax.Task.task_state)
  return _internal_task_state();
}
inline void Task::_internal_set_task_state(uint32_t value) {
  
  _impl_.task_state_ = value;
}
inline void Task::set_task_state(uint32_t value) {
  _internal_set_task_state(value);
  // @@protoc_insertion_point(field_set:arax.Task.task_state)
}

// -------------------------------------------------------------------

// DataSet

// uint64 buffer = 1;
inline void DataSet::clear_buffer() {
  _impl_.buffer_ = uint64_t{0u};
}
inline uint64_t DataSet::_internal_buffer() const {
  return _impl_.buffer_;
}
inline uint64_t DataSet::buffer() const {
  // @@protoc_insertion_point(field_get:arax.DataSet.buffer)
  return _internal_buffer();
}
inline void DataSet::_internal_set_buffer(uint64_t value) {
  
  _impl_.buffer_ = value;
}
inline void DataSet::set_buffer(uint64_t value) {
  _internal_set_buffer(value);
  // @@protoc_insertion_point(field_set:arax.DataSet.buffer)
}

// uint64 accel = 2;
inline void DataSet::clear_accel() {
  _impl_.accel_ = uint64_t{0u};
}
inline uint64_t DataSet::_internal_accel() const {
  return _impl_.accel_;
}
inline uint64_t DataSet::accel() const {
  // @@protoc_insertion_point(field_get:arax.DataSet.accel)
  return _internal_accel();
}
inline void DataSet::_internal_set_accel(uint64_t value) {
  
  _impl_.accel_ = value;
}
inline void DataSet::set_accel(uint64_t value) {
  _internal_set_accel(value);
  // @@protoc_insertion_point(field_set:arax.DataSet.accel)
}

// string str_val = 3;
inline void DataSet::clear_str_val() {
  _impl_.str_val_.ClearToEmpty();
}
inline const std::string& DataSet::str_val() const {
  // @@protoc_insertion_point(field_get:arax.DataSet.str_val)
  return _internal_str_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataSet::set_str_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.str_val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arax.DataSet.str_val)
}
inline std::string* DataSet::mutable_str_val() {
  std::string* _s = _internal_mutable_str_val();
  // @@protoc_insertion_point(field_mutable:arax.DataSet.str_val)
  return _s;
}
inline const std::string& DataSet::_internal_str_val() const {
  return _impl_.str_val_.Get();
}
inline void DataSet::_internal_set_str_val(const std::string& value) {
  
  _impl_.str_val_.Set(value, GetArenaForAllocation());
}
inline std::string* DataSet::_internal_mutable_str_val() {
  
  return _impl_.str_val_.Mutable(GetArenaForAllocation());
}
inline std::string* DataSet::release_str_val() {
  // @@protoc_insertion_point(field_release:arax.DataSet.str_val)
  return _impl_.str_val_.Release();
}
inline void DataSet::set_allocated_str_val(std::string* str_val) {
  if (str_val != nullptr) {
    
  } else {
    
  }
  _impl_.str_val_.SetAllocated(str_val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_val_.IsDefault()) {
    _impl_.str_val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arax.DataSet.str_val)
}

// -------------------------------------------------------------------

// AccelRequest

// uint32 type = 1;
inline void AccelRequest::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t AccelRequest::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t AccelRequest::type() const {
  // @@protoc_insertion_point(field_get:arax.AccelRequest.type)
  return _internal_type();
}
inline void AccelRequest::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void AccelRequest::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:arax.AccelRequest.type)
}

// -------------------------------------------------------------------

// AraxProc

// uint64 id = 1;
inline void AraxProc::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t AraxProc::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t AraxProc::id() const {
  // @@protoc_insertion_point(field_get:arax.AraxProc.id)
  return _internal_id();
}
inline void AraxProc::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void AraxProc::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:arax.AraxProc.id)
}

// -------------------------------------------------------------------

// ProcRequest

// string func_name = 2;
inline void ProcRequest::clear_func_name() {
  _impl_.func_name_.ClearToEmpty();
}
inline const std::string& ProcRequest::func_name() const {
  // @@protoc_insertion_point(field_get:arax.ProcRequest.func_name)
  return _internal_func_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcRequest::set_func_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.func_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arax.ProcRequest.func_name)
}
inline std::string* ProcRequest::mutable_func_name() {
  std::string* _s = _internal_mutable_func_name();
  // @@protoc_insertion_point(field_mutable:arax.ProcRequest.func_name)
  return _s;
}
inline const std::string& ProcRequest::_internal_func_name() const {
  return _impl_.func_name_.Get();
}
inline void ProcRequest::_internal_set_func_name(const std::string& value) {
  
  _impl_.func_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcRequest::_internal_mutable_func_name() {
  
  return _impl_.func_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcRequest::release_func_name() {
  // @@protoc_insertion_point(field_release:arax.ProcRequest.func_name)
  return _impl_.func_name_.Release();
}
inline void ProcRequest::set_allocated_func_name(std::string* func_name) {
  if (func_name != nullptr) {
    
  } else {
    
  }
  _impl_.func_name_.SetAllocated(func_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.func_name_.IsDefault()) {
    _impl_.func_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arax.ProcRequest.func_name)
}

// -------------------------------------------------------------------

// RequestBuffer

// uint64 id = 1;
inline void RequestBuffer::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t RequestBuffer::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t RequestBuffer::id() const {
  // @@protoc_insertion_point(field_get:arax.RequestBuffer.id)
  return _internal_id();
}
inline void RequestBuffer::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void RequestBuffer::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:arax.RequestBuffer.id)
}

// uint64 buffer_size = 2;
inline void RequestBuffer::clear_buffer_size() {
  _impl_.buffer_size_ = uint64_t{0u};
}
inline uint64_t RequestBuffer::_internal_buffer_size() const {
  return _impl_.buffer_size_;
}
inline uint64_t RequestBuffer::buffer_size() const {
  // @@protoc_insertion_point(field_get:arax.RequestBuffer.buffer_size)
  return _internal_buffer_size();
}
inline void RequestBuffer::_internal_set_buffer_size(uint64_t value) {
  
  _impl_.buffer_size_ = value;
}
inline void RequestBuffer::set_buffer_size(uint64_t value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:arax.RequestBuffer.buffer_size)
}

// -------------------------------------------------------------------

// ProcCounter

// uint32 proc_counter = 1;
inline void ProcCounter::clear_proc_counter() {
  _impl_.proc_counter_ = 0u;
}
inline uint32_t ProcCounter::_internal_proc_counter() const {
  return _impl_.proc_counter_;
}
inline uint32_t ProcCounter::proc_counter() const {
  // @@protoc_insertion_point(field_get:arax.ProcCounter.proc_counter)
  return _internal_proc_counter();
}
inline void ProcCounter::_internal_set_proc_counter(uint32_t value) {
  
  _impl_.proc_counter_ = value;
}
inline void ProcCounter::set_proc_counter(uint32_t value) {
  _internal_set_proc_counter(value);
  // @@protoc_insertion_point(field_set:arax.ProcCounter.proc_counter)
}

// -------------------------------------------------------------------

// AccelDescriptor

// int32 index = 1;
inline void AccelDescriptor::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t AccelDescriptor::_internal_index() const {
  return _impl_.index_;
}
inline int32_t AccelDescriptor::index() const {
  // @@protoc_insertion_point(field_get:arax.AccelDescriptor.index)
  return _internal_index();
}
inline void AccelDescriptor::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void AccelDescriptor::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:arax.AccelDescriptor.index)
}

// string type = 2;
inline void AccelDescriptor::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& AccelDescriptor::type() const {
  // @@protoc_insertion_point(field_get:arax.AccelDescriptor.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccelDescriptor::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arax.AccelDescriptor.type)
}
inline std::string* AccelDescriptor::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:arax.AccelDescriptor.type)
  return _s;
}
inline const std::string& AccelDescriptor::_internal_type() const {
  return _impl_.type_.Get();
}
inline void AccelDescriptor::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* AccelDescriptor::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* AccelDescriptor::release_type() {
  // @@protoc_insertion_point(field_release:arax.AccelDescriptor.type)
  return _impl_.type_.Release();
}
inline void AccelDescriptor::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arax.AccelDescriptor.type)
}

// -------------------------------------------------------------------

// RevisionResponse

// string revision = 1;
inline void RevisionResponse::clear_revision() {
  _impl_.revision_.ClearToEmpty();
}
inline const std::string& RevisionResponse::revision() const {
  // @@protoc_insertion_point(field_get:arax.RevisionResponse.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevisionResponse::set_revision(ArgT0&& arg0, ArgT... args) {
 
 _impl_.revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:arax.RevisionResponse.revision)
}
inline std::string* RevisionResponse::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:arax.RevisionResponse.revision)
  return _s;
}
inline const std::string& RevisionResponse::_internal_revision() const {
  return _impl_.revision_.Get();
}
inline void RevisionResponse::_internal_set_revision(const std::string& value) {
  
  _impl_.revision_.Set(value, GetArenaForAllocation());
}
inline std::string* RevisionResponse::_internal_mutable_revision() {
  
  return _impl_.revision_.Mutable(GetArenaForAllocation());
}
inline std::string* RevisionResponse::release_revision() {
  // @@protoc_insertion_point(field_release:arax.RevisionResponse.revision)
  return _impl_.revision_.Release();
}
inline void RevisionResponse::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  _impl_.revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.revision_.IsDefault()) {
    _impl_.revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:arax.RevisionResponse.revision)
}

// -------------------------------------------------------------------

// AccelListRequest

// int32 type = 1;
inline void AccelListRequest::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t AccelListRequest::_internal_type() const {
  return _impl_.type_;
}
inline int32_t AccelListRequest::type() const {
  // @@protoc_insertion_point(field_get:arax.AccelListRequest.type)
  return _internal_type();
}
inline void AccelListRequest::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void AccelListRequest::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:arax.AccelListRequest.type)
}

// bool physical = 2;
inline void AccelListRequest::clear_physical() {
  _impl_.physical_ = false;
}
inline bool AccelListRequest::_internal_physical() const {
  return _impl_.physical_;
}
inline bool AccelListRequest::physical() const {
  // @@protoc_insertion_point(field_get:arax.AccelListRequest.physical)
  return _internal_physical();
}
inline void AccelListRequest::_internal_set_physical(bool value) {
  
  _impl_.physical_ = value;
}
inline void AccelListRequest::set_physical(bool value) {
  _internal_set_physical(value);
  // @@protoc_insertion_point(field_set:arax.AccelListRequest.physical)
}

// -------------------------------------------------------------------

// AccelListResponse

// uint64 accel_num = 1;
inline void AccelListResponse::clear_accel_num() {
  _impl_.accel_num_ = uint64_t{0u};
}
inline uint64_t AccelListResponse::_internal_accel_num() const {
  return _impl_.accel_num_;
}
inline uint64_t AccelListResponse::accel_num() const {
  // @@protoc_insertion_point(field_get:arax.AccelListResponse.accel_num)
  return _internal_accel_num();
}
inline void AccelListResponse::_internal_set_accel_num(uint64_t value) {
  
  _impl_.accel_num_ = value;
}
inline void AccelListResponse::set_accel_num(uint64_t value) {
  _internal_set_accel_num(value);
  // @@protoc_insertion_point(field_set:arax.AccelListResponse.accel_num)
}

// repeated .arax.AccelDescriptor descriptors = 2;
inline int AccelListResponse::_internal_descriptors_size() const {
  return _impl_.descriptors_.size();
}
inline int AccelListResponse::descriptors_size() const {
  return _internal_descriptors_size();
}
inline void AccelListResponse::clear_descriptors() {
  _impl_.descriptors_.Clear();
}
inline ::arax::AccelDescriptor* AccelListResponse::mutable_descriptors(int index) {
  // @@protoc_insertion_point(field_mutable:arax.AccelListResponse.descriptors)
  return _impl_.descriptors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arax::AccelDescriptor >*
AccelListResponse::mutable_descriptors() {
  // @@protoc_insertion_point(field_mutable_list:arax.AccelListResponse.descriptors)
  return &_impl_.descriptors_;
}
inline const ::arax::AccelDescriptor& AccelListResponse::_internal_descriptors(int index) const {
  return _impl_.descriptors_.Get(index);
}
inline const ::arax::AccelDescriptor& AccelListResponse::descriptors(int index) const {
  // @@protoc_insertion_point(field_get:arax.AccelListResponse.descriptors)
  return _internal_descriptors(index);
}
inline ::arax::AccelDescriptor* AccelListResponse::_internal_add_descriptors() {
  return _impl_.descriptors_.Add();
}
inline ::arax::AccelDescriptor* AccelListResponse::add_descriptors() {
  ::arax::AccelDescriptor* _add = _internal_add_descriptors();
  // @@protoc_insertion_point(field_add:arax.AccelListResponse.descriptors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::arax::AccelDescriptor >&
AccelListResponse::descriptors() const {
  // @@protoc_insertion_point(field_list:arax.AccelListResponse.descriptors)
  return _impl_.descriptors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace arax

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_arax_2eproto
